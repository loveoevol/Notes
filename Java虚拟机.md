# Java虚拟机

### 2.1	运行时数据区

#### 2.1.1	程序计数器

> ​		程序计数器是一块内存区域，在寄存器中，保存的是字节码指令的地址，字节码解释器是通过寄存器中的值来找到下一个执行的指令，因此，程序的分支、循环、跳转、异常处理、线程恢复，都依赖程序计数器实现。
>
> ​		程序计数器是线程私有的，因为，Java虚拟机多线程是通过分配处理时间，轮流切换执行，所以，在一个处理器中只能有一个线程执行，为了保证线程恢复后能正确执行，需要为每个线程提供一个程序计数器。

####	2.1.2	Java虚拟机栈

> ​		Java虚拟机栈描述的是Java方法的内存模型，线程私有，每次方法调用都会创建一个栈帧，在虚拟机中，方法的执行伴随着栈帧的入栈和出栈过程。栈帧存储的是局部变量表、操作数栈、动态链接、方法出口等信息。
>
> ​		局部变量表存储基本类型、引用类型、return address（存储的是字节码的地址）。单位是slot，double、long占用两个字节，其他占一个字节。在方法执行的时候，虚拟机分配给局部变量表的大小在编译期间是固定的，在方法运行时不会动态改变。

####	2.1.3	本地方法栈

> ​		本地方法栈与Java虚拟机栈的实现没有任何差别，只不过Java虚拟机栈为Java方法服务，本地方法栈为Java虚拟机使用到的本地方法服务。主流 Hot-Spot 虚拟机将本地方法栈和虚拟机栈合并。

####	2.1.4	Java堆

> ​		堆存储的几乎是所有对象的实例和数组，是GC管理的内存区域，大小是可扩展的，在逻辑上连续的存储空间，为各线程共享。

####	2.1.5	方法区

> ​		方法区存储的是类型信息、常量、静态变量、即时编译后的代码缓存等数据，为各线程共享。

> ​		JDK 8以前使用永久代实现方法区（垃圾收集器的分代设计扩展至方法区），JDK 8完全废弃永久代，改用本地内存实现方法区，称为元空间。
>
> ​		方法区的内存回收主要是常量池和类型卸载

####	2.1.6	运行时常量池

> ​		运行时常量池是方法区的一部分。Class文件存放版本、字段、方法、接口等描述信息和常量表。常量池表中的字面量和符号引用在类加载后存放到运行时常量池。
>
> ​		运行时常量池保存Class文件中描述的符号引用，还会把由符号引用翻译出来的直接引用保存在常量池中。
>
> ​		并非预置入Class文件常量池中的内容才可进入运行时常量池，在运行时也可进入常量池，如String类的intern方法。

####	2.1.7	直接内存

> ​		直接内存并不是Java虚拟机规范定义的内存区域，但这部分内存也会造成OOM错误。
>
> ​		NIO类引入了基于通道与缓冲区的I/O方式，它可以使用本地方法分配堆外内存，通过堆内对象`DirectByteBuffer`直接操控这部分区域，提高了性能。

###	2.2	Spot-Hot虚拟机探秘

####	2.2.1	对象的创建

>​		当Java虚拟机遇到new这个关键字的指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否已经被加载、解析、初始化。
>
>​		在类加载检查通过后，为新生对象分配内存。对象所需内存大小在类加载过后便可确定。分配内存的大小有两种方式，指针碰撞法、空闲列表法。
>
>​		指针碰撞法：要求内存规整，在使用过的内存和未使用过的内存中间有一个指针，在分配内存时，仅仅把那个指针移动到与对象所需大小一致的距离。
>
>​		空闲列表法：内存不要求规整，由虚拟机维护一个列表，记录哪块内存是使用过的，哪块是未使用过的，分配内存时，在列表中找出较大的一块，并更新列表中的记录。
>
>​		Java堆是否规整由所采用的垃圾收集器是否有空间压缩整理的能力决定。
>
>​		另一个考虑的问题线程安全问题：在频繁创建对象分配空间时，可能会存在线程安全的问题。解决方式有以下两种：
>
>>   * 对分配空间的动作进行同步处理——虚拟机采用的是CAS配上失败重试的方式保证更新操作的原子性。
>>   * 把内存分配的动作按照线程划分在不同的空间中，即本地线程分配缓冲(TLAB)——每个线程预先在堆中分配一小块空间。

> ​		内存分配完成之后，将初始化为零值。
>
> ​		接下来还要对对象进行必要的设置，如这个对象是哪个类的实例，如何找到类的元数据信息、对象的哈希码，这些信息存放到**对象头**中。根据虚拟机运行状态的不同，如是否启用偏向锁，对象头会有不同的设置方式。
>
> ​		以上工作完成之后，从虚拟机角度来看，对象已经创建完成，但是从程序角度来看，对象创建才刚刚开始，init方法还未执行，按照程序员的意愿对对象初始化，对象创建才真正完成。
>
> ```mermaid
> 
> graph 
> A[对象创建] -->B(检查new关键字后的参数是否能在Class文件中的常量池中定位到符号引用)
>     B --> C{检查符号引用所代表的类是否被加载,解析,验证}
>     C -->|否| D[类加载]
>     C -->|是| E[内存分配]
>     E -->F(初始化零值)
>     F -->G(对对象进行必要设置)
>     G -->H(执行初始化方法)
> ```

####	2.2.2	对象的内存分配

> ​		对象的存储布局划分为三个部分：对象头、实例数据、对齐填充。		

**对象头**

> ​		对象头存储两类信息，第一类存储对象自身运行时的数据，如哈希码、GC分代年龄、锁状态标志、线程持有锁、偏向线程、偏向时间戳。
>
> ​		对象头的另一部分是类型指针，即对象指向它的类型元数据的指针（指向方法区），Java虚拟机通过这个指针找到它是哪个类的实例。并不是所有的Java虚拟机都保存对象的类型指针，换句话说，并不一定通过类型指针找到它属于哪个类的实例。此外，如果对象是一个数组，那么对象头中还要有一块保存数组长度的区域。

**实例数据**

> ​		实例数据部分是对象真正存储的有效数据。即我们在程序中所定义的各种类型的字段内容，无论是从父类继承下来的，还是子类定义的字段，都必须记录下来。

**对齐填充**

> ​		没有特别含义，起到占位符的作用，Hot-Spot虚拟机要求对象大小为8的整数倍。

####	2.2.3	对象的访问方式

> ​		Java程序通过栈上的reference数据操作堆上的具体对象（对象引用存储在栈中本地变量表中），reference类型是一个指向对象的引用，虚拟机并没有规定这个引用应该通过什么方式去定位，访问堆中具体对象的位置，由具体的虚拟机而定。主流的访问方式有两种：
>
> >1. 句柄：reference中存储的是句柄中的地址，句柄中存储的是对象实例数据的地址和对象类型地址。
> >2. 直接指针访问：reference中存储的直接就是对象地址，需要考虑如何存放对象类型地址。（主流方式）

##	3	垃圾收集器与内存分配策略

###	3.1	概述

> ​		垃圾收集器关注的是Java堆和方法区的内存回收。

###	3.2	对象已死？

####	3.2.1	引用计数算法

> ​		在对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减一，任何时刻计数器为零时，对象就是不可能被使用的。
>
> ​		引用计数法很难解决对象之间的循环引用问题。		

####	3.2.2	可达性分析算法

**基本思路**

> ​	通过一些称为`GC Roots `的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到`GC Roots` 没有任何引用链，或者用图论的话说就是从`GC Roots`到这个对象不可达时，则证明此对象是不可能再使用的。

**固定可作为`GC Roots`对象包括以下几种**

> 1. 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量。
> 2. 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
> 3. 在方法区中常量引用的对象，譬如字符串常量池里的引用。
> 4. 在本地方法栈JNI（通常所说的本地方法）中引用的对象。
> 5. Java虚拟机内部的引用，如基本类型对应的Class对象，一些常驻的异常对象，还有系统类加载器。
> 6. 所有被同步锁持有的对象。
> 7. 反应Java虚拟机内部情况的JMXBean、JVMTI注册中的回调，本地代码缓存。
> 8. 除了这些固定的集合,根据用户所选用的垃圾收集器和回收区域的不同，还可以有其他对象临时性的加入，共同构成完整的GC Roots集合。

####	3.2.3	再谈引用

> ​		强引用是最传统的引用定义，是指代码中最普遍的引用赋值，即类似`Object obj=new Object()`这种关系，无论在任何情况下，只要强引用关系存在，垃圾收集器就永远不会回收被引用的对象。
>
> ​		软引用描述的是一些还有用，但非必须的对象，只被软引用关联的对象，在系统将要发生内存溢出前，会把这些对象列进回收范围进行二次回收，如果回收后还是内存不足，才会抛出异常。使用`SoftReference`类实现软引用。
>
> ​		弱引用也是用来描述那些非必须的对象，它只能存活在下次垃圾回收之前。使用`WeakReference`实现弱引用。
>
> ​		虚引用是最弱的一种引用关系，一个对象是否有虚引用存在完全不会对生存期产生影响，也无法通过虚引用来取得一个对象的实例，它的存在只是为了能在对象被回收前得到通知。

####	3.2.4	生存还是死亡？

> ​		即使在可达性分析算法中判定为不可达的对象，它也不是非死不可的，宣告一个对象的真正死亡，至少要经过两次标记过程：如果对象在可达性分析后没有与`GC Roots`相关联的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是，此对象是否有必要执行finalize方法，假如对象没有覆盖finalize方法，或finalize方法已经被虚拟机调用过，那么这两种情况都视为没有必要执行。
>
> ​		如果这个对象被判定确有必要执行finalize方法，那么该对象会被放在一个名为F-Queue的队列，稍后由一条虚拟机自行建立、低调度优先级的Finalizer线程去执行他们的finalize方法，但并不承诺等待他执行结束。finalize方法是对象逃脱死亡命运的最后一次机会，稍后虚拟机会对F-Queue中的对象进行二次标记，如果对象要在finalize中拯救自己——只需将自己重新与引用链建立关系，那在二次标记时，它将被移出“即将回收”的集合。

####	3.2.5	回收方法区

> ​		方法区的回收主要有两种类型：废弃的常量和不再使用的类型。
>
> ​	判定一个类型是否属于“不在被使用的类需要同时满足三个条件”
>
> >1. 该类所有的实例都已经被回收。
> >2. 加载该类的类加载器已经被回收。
> >3. 该类对应的类对象在其他地方没有被使用。

###	3.3	垃圾收集算法

> ​		从判定对象消亡的角度出发，垃圾收集算法分为“引用计数式垃圾收集”、“追踪式垃圾收集”，以下所说均为追踪式垃圾收集。

####	3.3.1	分代收集理论

> ​		分代收集理论建立在两个假说之上：
>
> > 	1. 弱分代假说：大多数对象都是朝生夕灭的。
> > 	1. 强分代假说：熬过越多次垃圾收集过程的对象，就越难以消亡。		

> ​		分代假说奠定了垃圾收集器的设计原则：收集器应该将堆划分为不同区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集的次数）分配到不同的区域。一个区域的对象是朝生夕灭的，在回收时只需考虑如何保留少量存活对象而以较低代价回收大量空间；如果对象很难消亡，就以较低频率回收这个区域的对象。
>
> ​		由以上两个假说可得到一个隐含推论：
>
> > 	3. 跨代引用假说：跨代引用相对于同代引用只占极少数。

> ​		依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为记忆集），这个结构把老年代划分若干小块，标识出哪一块存在跨代引用。此后当发生Minor GC后，只有包含了跨代引用的小块才会被加入到GC Roots中扫描。

> ​	**名词解释**
>
> >   *	**部分收集（Partial GC）**：指目标不是完整收集整个堆的垃圾收集，其又分为：
> >     *	**新生代收集（Minor GC/Young GC）**：指目标只是新生代的垃圾收集。
> >     *	**老年代收集（Major GC/Old GC)**：指目标只是老年代的垃圾收集。
> >     *	**混合收集（Mixed GC)**：指目标回收整个新生代和部分老年代。
> >   *	**整堆收集（Full GC）**：收集整个Java堆和方法区的垃圾收集。

####	3.3.2	标记-清除算法

> ​		首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，但也可反过来。标记过程就是判定对象是否属于垃圾的过程（可达性分析）。
>
> **缺点**
>
> > 1. 执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分对象是可回收的，这时必须进行大量标记-清除动作，导致标记和清除两个过程的效率随对象数量的增长而降低。
> > 2. 内存空间碎片化问题，标记和清除之后会产生大量不连续的内存碎片，空间碎片过多会导致程序在分配较大对象时无法找到连续空间而不得不提前触发GC。

####	3.3.3	标记-复制算法

> ​		将可用内存按容量划分大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将该区域还活着的对象复制到另一块内存，然后把已使用过的内存一次清理掉。主流虚拟机使用这种算法回收新生代。缺点是浪费空间。
>
> **优化——Apple回收**
>
> ​		将内存划分Eden空间和两块survivor空间，只使用Eden和一块survivor空间，在垃圾收集时，将活着的对象放在另一块survivor空间，然后清理已使用过的内存空间。如果survivor不足以容纳存活的对象，将使用老年代分配担保。

####	3.3.4	标记整理算法

> ​		标记过程与标记清除算法一样，但后续步骤是将存活对象向空间一端移动，进而清理边界之后的空间。老年代的收集使用该算法。

##	6	类文件结构

###	6.3	Class类文件的结构

> ​		class文件是一组以8字节为基本单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件中，中间没有添加任何分隔符。当遇到8字节以上空间的数据项时，则会按照高位在前的方式（低位地址是高位）分割成若干个8字节进行存储。
>
> ​		文件格式采用类似于c语言结构体的伪结构来存储数据，只有两种数据类型：无符号数和表。
>
> > * 无符号数：属于基本的数据类型，以u1、u2、u4、u8 来分别代表1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或按照UTF-8编码的字符串值。
> > * 表：由多个无符号数或者其他表作为数据项构成的复合数据类型。表的命名习惯以“_info”结尾。

> ​		无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的数据，这时候称这一系列的某一类型连续的数据为某一类型的“集合”。

####	6.3.1	魔数和class文件的版本

> * 每个class文件头四个字节（0xCAFEBABE）被称为魔术。
> * 第五和第六个字节为此版本号
> * 第七和第八个字节为主版本号

####	6.3.2	常量池

> ​		版本号之后是常量池，常量池入口u2类型的数据表示常量池的容量，计数从一开始，索引为0表示不引用任何一个常量池项目。
>
> ​		常量池主要存放两大类常量：字面量和符号引用。
>
> > * 字面量：文本字符串被声明final的常量值
> >
> > * 符号引用：
> >
> >   > 1. 被模块导出或者开放的包
> >   > 2. 类和接口的全限定名
> >   > 3. 字段名称和描述符
> >   > 4. 方法名称和描述符
> >   > 5. 方法句柄和方法类型
> >   > 6. 动态调用点和动态常量

> ​		在class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址。也就无法被虚拟机直接使用的。当虚拟机被类加载时，将会从常量池得到对应符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中。
>
> ​		常量池中每一项都是一个表。截止到jdk13共有17种常量。
>
> ​		这17类表起始的第一位是u1字节的标志位。

|               类型               | 标志 |             描述             |
| :------------------------------: | :--: | :--------------------------: |
|        CONSTANT_Utf8_info        |  1   |      UTF-8编码的字符串       |
|      CONSTANT_Integer_info       |  3   |          整型字面量          |
|       CONSTANT_Float_info        |  4   |         浮点型字面量         |
|        CONSTANT_Long_info        |  5   |         长整型字面量         |
|       CONSTANT_Double_info       |  6   |      双精度浮点型字面量      |
|       CONSTANT_Class_info        |  7   |      类或接口的符号引用      |
|       CONSTANT_String_info       |  8   |      字符串类型的字面量      |
|      CONSTANT_Fieldref_info      |  9   |         字段符号引用         |
|     CONSTANT_Methodref_info      |  10  |         方法符号引用         |
| CONSTANT_InterfaceMethodref_info |  11  |     接口中的方法符号引用     |
|    CONSTANT_NameAndType_info     |  12  |   字段或方法的部分符号引用   |
|  CONSTANT_MethodrefHandler_info  |  15  |         方法处理句柄         |
|   CONSTANT_MethodrefType_info    |  16  |           方法类型           |
|      CONSTANT_Dynamic_info       |  17  |     表示一个动态计算常量     |
|   CONSTANT_InvokeDynamic_info    |  18  |    表示一个动态方法调用点    |
|       CONSTANT_Model_info        |  19  |         表示一个模块         |
|      CONSTANT_Package_info       |  20  | 表示一个模块中开放或导出的包 |





