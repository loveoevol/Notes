# Java虚拟机

### 2.1	运行时数据区

#### 2.1.1	程序计数器

> ​		程序计数器是一块内存区域，在寄存器中，保存的是字节码指令的地址，字节码解释器是通过寄存器中的值来找到下一个执行的指令，因此，程序的分支、循环、跳转、异常处理、线程恢复，都依赖程序计数器实现。
>
> ​		程序计数器是线程私有的，因为，Java虚拟机多线程是通过分配处理时间，轮流切换执行，所以，在一个处理器中只能有一个线程执行，为了保证线程恢复后能正确执行，需要为每个线程提供一个程序计数器。

####	2.1.2	Java虚拟机栈

> ​		Java虚拟机栈描述的是Java方法的内存模型，线程私有，每次方法调用都会创建一个栈帧，在虚拟机中，方法的执行伴随着栈帧的入栈和出栈过程。栈帧存储的是局部变量表、操作数栈、动态链接、方法出口等信息。
>
> ​		局部变量表存储基本类型、引用类型、return address（存储的是字节码的地址）。单位是slot，double、long占用两个字节，其他占一个字节。在方法执行的时候，虚拟机分配给局部变量表的大小在编译期间是固定的，在方法运行时不会动态改变。

####	2.1.3	本地方法栈

> ​		本地方法栈与Java虚拟机栈的实现没有任何差别，只不过Java虚拟机栈为Java方法服务，本地方法栈为Java虚拟机使用到的本地方法服务。主流 Hot-Spot 虚拟机将本地方法栈和虚拟机栈合并。

####	2.1.4	Java堆

> ​		堆存储的几乎是所有对象的实例和数组，是GC管理的内存区域，大小是可扩展的，在逻辑上连续的存储空间，为各线程共享。

####	2.1.5	方法区

> ​		方法区存储的是类型信息、常量、静态变量、即时编译后的代码缓存等数据，为各线程共享。

> ​		JDK 8以前使用永久代实现方法区（垃圾收集器的分代设计扩展至方法区），JDK 8完全废弃永久代，改用本地内存实现方法区，称为元空间。
>
> ​		方法区的内存回收主要是常量池和类型卸载

####	2.1.6	运行时常量池

> ​		运行时常量池是方法区的一部分。Class文件存放版本、字段、方法、接口等描述信息和常量表。常量池表中的字面量和符合引用在类加载后存放到运行时常量池。
>
> ​		运行时常量池保存Class文件中描述的符号引用，还会把由符号引用翻译出来的直接引用保存在常量池中。
>
> ​		并非预置入Class文件常量池中的内容才可进入运行时常量池，在运行时也可进入常量池，如String类的intern方法。

####	2.1.7	直接内存

> ​		直接内存并不是Java虚拟机规范定义的内存区域，但这部分内存也会造成OOM错误。
>
> ​		NIO类引入了基于通道与缓冲区的I/O方式，它可以使用本地方法分配堆外内存，通过堆内对象`DirectByteBuffer`直接操控这部分区域，提高了性能。

###	2.2	Spot-Hot虚拟机探秘

####	2.2.1	对象的创建

>​		当Java虚拟机遇到new这个关键字的指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否已经被加载、解析、初始化。
>
>​		在类加载检查通过后，为新生对象分配内存。对象所需内存大小在类加载过后便可确定。分配内存的大小有两种方式，指针碰撞法、空闲列表法。
>
>​		指针碰撞法：要求内存规整，在使用过的内存和未使用过的内存中间有一个指针，在分配内存时，仅仅把那个指针移动到与对象所需大小一致的距离。
>
>​		空闲列表法：内存不要求规整，由虚拟机维护一个列表，记录哪块内存是使用过的，哪块是未使用过的，分配内存时，在列表中找出较大的一块，并更新列表中的记录。
>
>​		Java堆是否规整由所采用的垃圾收集器是否有空间压缩整理的能力决定。
>
>​		另一个考虑的问题线程安全问题：在频繁创建对象分配空间时，可能会存在线程安全的问题。解决方式有以下两种：
>
>>   * 对分配空间的动作进行同步处理——虚拟机采用的是CAS配上失败重试的方式保证更新操作的原子性。
>>   * 把内存分配的动作按照线程划分在不同的空间中，即本地线程分配缓冲(TLAB)——每个线程预先在堆中分配一小块空间。

> ​		内存分配完成之后，将初始化为零值。
>
> ​		接下来还要对对象进行必要的设置，如这个对象是哪个类的实例，如何找到类的元数据信息、对象的哈希码，这些信息存放到**对象头**中。根据虚拟机运行状态的不同，如是否启用偏向锁，对象头会有不同的设置方式。
>
> ​		以上工作完成之后，从虚拟机角度来看，对象已经创建完成，但是从程序角度来看，对象创建才刚刚开始，init方法还未执行，按照程序员的意愿对对象初始化，对象创建才真正完成。
>
> ```mermaid
> 
> graph 
> A[对象创建] -->B(检查new关键字后的参数是否能在Class文件中的常量池中定位到符号引用)
>     B --> C{检查符号引用所代表的类是否被加载,解析,验证}
>     C -->|否| D[类加载]
>     C -->|是| E[内存分配]
>     E -->F(初始化零值)
>     F -->G(对对象进行必要设置)
>     G -->H(执行初始化方法)
> ```

####	2.2.2	对象的内存分配

> ​		对象的存储布局划分为三个部分：对象头、实例数据、对齐填充。		

**对象头**

> ​		对象头存储两类信息，第一类存储对象自身运行时的数据，如哈希码、GC分代年龄、锁状态标志、线程持有锁、偏向线程、偏向时间戳。
>
> ​		对象头的另一部分是类型指针，即对象指向它的类型元数据的指针（指向方法区），Java虚拟机通过这个指针找到它是哪个类的实例。并不是所有的Java虚拟机都保存对象的类型指针，换句话说，并不一定通过类型指针找到它属于哪个类的实例。此外，如果对象是一个数组，那么对象头中还要有一块保存数组长度的区域。

**实例数据**

> ​		实例数据部分是对象真正存储的有效数据。即我们在程序中所定义的各种类型的字段内容，无论是从父类继承下来的，还是子类定义的字段，都必须记录下来。

**对齐填充**

> ​		没有特别含义，起到占位符的作用，Hot-Spot虚拟机要求对象大小为8的整数倍。

####	2.2.3	对象的访问方式

> ​		Java程序通过栈上的reference数据操作堆上的具体对象（基本类型和对象引用存储在栈中本地变量表中），reference类型是一个指向对象的引用，虚拟机并没有规定这个引用应该通过什么方式去定位，访问堆中具体对象的位置，由具体的虚拟机而定。主流的访问方式有两种：
>
> >1. 句柄：reference中存储的是句柄中的地址，句柄中存储的是对象实例数据的地址和对象类型地址。
> >2. 直接指针访问：reference中存储的直接就是对象地址，需要考虑如何存放对象类型地址。（主流方式）

##	3	垃圾收集器与内存分配策略

###	3.1	概述

> ​		垃圾收集器关注的是Java堆和方法区的内存回收。

###	3.2	对象已死？

####	3.2.1	引用计数算法

> ​		在对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减一，任何时刻计数器为零时，对象就是不可能被使用的。
>
> ​		引用计数法很难解决对象之间的循环引用问题。		

####	3.2.2	可达性分析算法

**基本思路**

> ​	通过一些称为`GC Roots `的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如何某个对象到`GC Roots` 没有任何引用链，或者用图论的话说就是从`GC Roots`到这个对象不可达时，则证明此对象是不可能再使用的。

**固定可作为`GC Roots`对象包括以下几种**

> 1. 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量。
> 2. 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
> 3. 在方法区中常量引用的对象，譬如字符串常量池里的引用。
> 4. 在本地方法栈JNI（通常所说的本地方法）中引用的对象。
> 5. Java虚拟机内部的引用，如基本类型对应的Class对象，一些常驻的异常对象，还有系统类加载器。
> 6. 所有被同步锁持有的对象。
> 7. 反应Java虚拟机内部情况的JMXBean、JVMTI注册中的回调，本地代码缓存。
> 8. 除了这些固定的集合,根据用户所选用的垃圾收集器和回收区域的不同，还可以有其他对象临时性的加入，共同构成完整的GC Roots集合。

####	3.2.3	再谈引用

> ​		强引用是最传统的引用定义，是指代码中最普遍的引用赋值，即类似`Object obj=new Object()`这种关系，无论在任何情况下，只要强引用关系存在，垃圾收集器就永远不会回收被引用的对象。
>
> ​		软引用描述的是一些还有用，但非必须的对象，只被软引用关联的对象，在系统将要发生内存溢出前，会把这些对象列进回收范围进行二次回收，如果回收后还是内存不足，才会抛出异常。使用`SoftReference`类实现软引用。
>
> ​		弱引用也是用来描述那些非必须的对象，它只能存活在下次垃圾回收之前。使用`WeakReference`实现弱引用。
>
> ​		虚引用是最弱的一种引用关系，一个对象是否有虚引用存在完全不会对生存期产生影响，也无法通过虚引用来取得一个对象的实例，它的存在只是为了能在对象被回收前得到通知。

####	3.2.4	生存还是死亡？

> ​		即使在可达性分析算法中判定为不可达的对象，它也不是非死不可的，宣告一个对象的真正死亡，至少要经过两次标记过程：如果对象在可达性分析后没有与`GC Roots`相关联的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是，此对象是否有必要执行finalize方法，假如对象没有覆盖finalize方法，或finalize方法已经被虚拟机调用过，那么这两种情况都视为没有必要执行。
>
> ​		如果这个对象被判定确有必要执行finalize方法，那么该对象会被放在一个名为F-Queue的队列，稍后由一条虚拟机自行建立、低调度优先级的Finalizer线程去执行他们的finalize方法，但并不承诺等待他执行结束。finalize方法是对象逃脱死亡命运的最后一次机会，稍后虚拟机会对F-Queue中的对象进行二次标记，如果对象要在finalize中拯救自己——只需将自己重新与引用链建立关系，那在二次标记时，它将被移出“即将回收”的集合。

####	3.2.5	回收方法区

> ​		方法区的回收主要有两种类型：废弃的常量和不再使用的类型。
>
> ​	判定一个类型是否属于“不在被使用的类需要同时满足三个条件”
>
> >1. 该类所有的实例都已经被回收。
> >2. 加载该类的类加载器已经被回收。
> >3. 该类对应的类对象在其他地方没有被使用。

###	3.3	垃圾收集算法

> ​	从判定对象消亡的角度出发，垃圾收集算法分为“引用计数式垃圾收集”、“追踪式垃圾收集”，以下所说均为追踪式垃圾收集。

####	3.3.1	分代收集理论

